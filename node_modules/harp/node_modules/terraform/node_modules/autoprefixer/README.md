<<<<<<< HEAD
# Autoprefixer

<img align="right" width="94" height="71" src="http://ai.github.io/autoprefixer/logo.svg" title="Autoprefixer logo by Anton Lovchikov">

Parse CSS and add vendor prefixes to CSS rules using values
from [Can I Use](http://caniuse.com/).
=======
# Autoprefixer [![Build Status][ci-img]][ci]

<img align="right" width="94" height="71"
     src="http://postcss.github.io/autoprefixer/logo.svg"
     title="Autoprefixer logo by Anton Lovchikov">

[PostCSS] plugin to parse CSS and add vendor prefixes to CSS rules using values
from [Can I Use]. It is [recommended] by Google and used in Twitter,
and Taobao.
>>>>>>> dev

Write your CSS rules without vendor prefixes (in fact, forget about them
entirely):

```css
:fullscreen a {
<<<<<<< HEAD
    transition: transform 1s
}
```

Process your CSS by Autoprefixer:

```js
var prefixed = autoprefixer.process(css).css;
```

It will use the data on current browser popularity and properties support
to apply prefixes for you:

```css
:-webkit-full-screen a {
    -webkit-transition: -webkit-transform 1s;
            transition: transform 1s
}
:-moz-full-screen a {
    transition: transform 1s
}
:-ms-fullscreen a {
    transition: transform 1s
}
:fullscreen a {
    -webkit-transition: -webkit-transform 1s;
            transition: transform 1s
}
```

You can play with your CSS in the [interactive demo] of Autoprefixer.

Twitter account for news and releases: [@autoprefixer].

Sponsored by [Evil Martians]. Based on [PostCSS] framework.

[interactive demo]: http://jsfiddle.net/simevidas/udyTs/show/light/
[@autoprefixer]:    https://twitter.com/autoprefixer
[Evil Martians]:    http://evilmartians.com/
[PostCSS]:          https://github.com/ai/postcss

## Features

### Forget about prefixes

The best tool is a tool you can't see and one that does the work for you.
This is the main idea behind Autoprefixer.

Autoprefixer interface is simple: just forget about vendor prefixes
and write normal CSS according to the latest W3C specs. You don’t need
a special language (like Sass) or special mixins.

Because Autoprefixer is a postprocessor for CSS,
you can also use it with preprocessors, such as Sass, Stylus or LESS.

### Actual data from Can I Use

Autoprefixer uses the most recent data from [Can I Use](http://caniuse.com/),
understands which browsers are actual and popular and adds only the necessary
vendor prefixes.

It also cleans your CSS from old prefixes (like prefixed `border-radius`,
produced by many CSS libraries):

```css
a {
    -webkit-border-radius: 5px;
            border-radius: 5px
}
```

compiles to:

```css
a {
    border-radius: 5px
}
```

Note, that Autoprefixer doesn’t load Can I Use data every time. It takes it from
[caniuse-db](https://www.npmjs.org/package/caniuse-db) dependency.
So, if you use Autoprefixer from `npm`, try to keep your `autoprefixer`
and `caniuse-db` packages fresh to have only actual prefixes in your CSS.

### Flexbox, Gradients, etc.

Flexbox or gradients have different syntaxes in different browsers
(sometimes you need to recalculate angles, sometimes you need 2 old properties
instead of new one), but Autoprefixer hides this from you.

Just code by latest W3C specs and Autoprefixer will produce the code
for old browsers:
=======
    display: flex
}
```

Autoprefixer will use the data based on current browser popularity and property
support to apply prefixes for you. You try in the [interactive demo]
of Autoprefixer.

```css
:-webkit-full-screen a {
    display: -webkit-box;
    display: -webkit-flex;
    display: flex
}
:-moz-full-screen a {
    display: flex
}
:-ms-fullscreen a {
    display: -ms-flexbox;
    display: flex
}
:fullscreen a {
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex
}
```

Twitter account for news and releases: [@autoprefixer].

<a href="https://evilmartians.com/?utm_source=autoprefixer">
<img src="https://evilmartians.com/badges/sponsored-by-evil-martians.svg" alt="Sponsored by Evil Martians" width="236" height="54">
</a>

[interactive demo]: http://autoprefixer.github.io/
[@autoprefixer]:    https://twitter.com/autoprefixer
[recommended]:      https://developers.google.com/web/tools/setup/setup-buildtools#dont-trip-up-with-vendor-prefixes
[Can I Use]:        http://caniuse.com/
[PostCSS]:          https://github.com/postcss/postcss
[ci-img]:           https://travis-ci.org/postcss/autoprefixer.svg
[ci]:               https://travis-ci.org/postcss/autoprefixer

## Features

### Write Pure CSS

Working with Autoprefixer is simple: just forget about vendor prefixes
and write normal CSS according to the latest W3C specs. You don’t need
a special language (like Sass) or remember where you must use mixins.

Autoprefixer supports selectors (like `:fullscreen` and `::selection`),
unit function (`calc()`), at‑rules (`@support` and `@keyframes`) and properties.

Because Autoprefixer is a postprocessor for CSS,
you can also use it with preprocessors such as Sass, Stylus or LESS.

### Flexbox, Filters, etc.

Just write normal CSS according to the latest W3C specs and Autoprefixer
will produce the code for old browsers.
>>>>>>> dev

```css
a {
    display: flex;
}
```

compiles to:

```css
a {
    display: -webkit-box;
    display: -webkit-flex;
<<<<<<< HEAD
    display: -moz-box;
=======
>>>>>>> dev
    display: -ms-flexbox;
    display: flex
}
```

<<<<<<< HEAD
Autoprefixer has [22 special hacks] to fix browser’s differences.

[22 special hacks]: https://github.com/ai/autoprefixer/tree/master/lib/hacks

## Browsers

You can specify the browsers you want to target in your project:

```js
autoprefixer("last 1 version", "> 1%", "Explorer 7").process(css).css;
```

* `last 2 versions` is last versions for each browser. Like “last 2 versions”
  [strategy](http://support.google.com/a/bin/answer.py?answer=33864) in
  Google.
* `last 2 Chrome versions` is last versions of the specified browser.
* `> 5%` is browser versions, selected by global usage statistics.
* `Firefox > 20` is Firefox versions newer than 20.
* `Firefox >= 20` is Firefox version 20 or newer.
* `Firefox ESR` is the latest [Firefox ESR] version.
* `none` don’t set any browsers to clean CSS from any vendor prefixes.
* `ios 7` to set browser version directly.

Blackberry and stock Android browsers will not be used in `last n versions`.
You can add them by name:

```js
autoprefixer("last 1 version", "BlackBerry 10", "Android 4").process(css).css;
```

Browsers names (case insensitive):
* `Android` for old Android stock browser.
* `BlackBerry` or `bb` for Blackberry browser.
* `Chrome` for Google Chrome.
* `Firefox` or `ff` for Mozilla Firefox.
* `Explorer` or `ie` for Internet Explorer.
* `iOS` or `ios_saf` for iOS Safari.
* `Opera` for Opera.
* `Safari` for desktop Safari.
* `OperaMobile` or `op_mob` for Opera Mobile.
* `OperaMini` or `op_mini` for Opera Mini.
* `ChromeAndroid` or `and_chr` for Chrome for Android
  (mostly same as common `Chrome`).
* `FirefoxAndroid` or `and_ff` for Firefox for Android.
* `ExplorerMobile` or `ie_mob` for Internet Explorer Mobile.

By default, Autoprefixer uses `> 1%, last 2 versions, Firefox ESR, Opera 12.1`:
* Latest [Firefox ESR] is a 24 version.
* Opera 12.1 will be in list until Opera supports non-Blink 12.x branch.

[Firefox ESR]: http://www.mozilla.org/en/firefox/organizations/faq/

## Source Map

You must set input and output CSS files paths (by `from` and `to` options)
to generate a correct map.

Autoprefixer can modify previous source maps (for example, from Sass):
it will autodetect a previous map if it is listed in an annotation comment or
in a file near the input CSS. You can disable source map with `map: false` or
set the previous source map content manually to `map.prev` option (as a string
or a object).

```js
var result = autoprefixer.process(css, {
    map:   { prev: fs.readFileSync('main.sass.css.map') },
    from: 'main.sass.css',
    to:   'main.min.css'
});

result.css //=> CSS with source map annotation comment
result.map //=> Source map from main.sass to main.min.css

fs.writeFileSync('main.min.css.map', result.map);
```

Autoprefixer supports inline source maps too. If input CSS contains annotation
from the previous step with map in `data:uri`, Autoprefixer will update the
source map with prefixes changes and inine the new map back into the output CSS.

You can read more about source map options in
[PostCSS documentation](https://github.com/ai/postcss#source-map-1).

## Visual Cascade

Autoprefixer changes CSS indentation to create a nice visual cascade
of prefixes, if CSS is uncompressed:

```css
a {
    -webkit-box-sizing: border-box;
       -moz-box-sizing: border-box;
            box-sizing: border-box
}
```

You can disable cascade by `cascade: false` option.

## Safe Mode

PostCSS has special safe mode to parse broken CSS. If you will set `safe: true`
option to `process` method, it will try to fix any syntax error, that it founds
in CSS. For example, it will parse `a {` as `a {}`.

```js
autoprefixer.process('a {');                 // will throw "Unclosed block"
autoprefixer.process('a {', { safe: true }); // process CSS as a {}
```

It is useful for legacy code with a lot of hack. Other use case is a interactive
tools with live input, like
[Autoprefixer demo](http://jsfiddle.net/simevidas/udyTs/show/light/).

## Disabling

Autoprefixer was designed to have no interface. It is just work. If you need
some browser specific hack just write prefixed property after unprefixed.

```css
a {
    transform: scale(0.5);
    -moz-transform: scale(0.6)
}
```

If some prefixes was generated in wrong way, please create issue on GitHub.

But if you didn’t need Autoprefixer in some part of your CSS and you understand
why it is a best solution, you can use control comments to disable Autoprefixer.

```css
a {
    transition: 1s; /* it will be prefixed */
}

b {
    /* autoprefixer: off */
    transition: 1s; /* it will not be prefixed */
}
```

Control comment disable Autoprefixer in rule, where you place it.
So Autoprefixer will not works in entiry `b` rule, not only after comment.

Also you can use comment recursively:

```css
/* autoprefixer: off */
@support (transition: all) {
    /* autoprefixer: on */
    a {
        /* autoprefixer: off */
    }
}
```

## Debug

You can check which browsers are selected and which properties will be prefixed:

```js
info = autoprefixer("last 1 version").info();
console.log(info);
```

Or by CLI command:

```sh
autoprefixer -i
=======
Autoprefixer has [27 special hacks] to fix web browser differences.

[27 special hacks]: https://github.com/postcss/autoprefixer/tree/master/lib/hacks

### Only Actual Prefixes

Autoprefixer utilizes the most recent data from [Can I Use]
to add only necessary vendor prefixes.

It also removes old, unnecessary prefixes from your CSS
(like `border-radius` prefixes, produced by many CSS libraries).

```css
a {
    -webkit-border-radius: 5px;
            border-radius: 5px;
}
```

compiles to:

```css
a {
    border-radius: 5px;
}
```

[Can I Use]: http://caniuse.com/

## Browsers

Autoprefixer uses [Browserslist], so you can specify the browsers
you want to target in your project by queries like `last 2 versions`
or `> 5%`.

If you don’t provide the browsers option, Browserslist will try
to find the `browserslist` config in parent dirs.

See [Browserslist docs] for queries, browser names, config format,
and default value.

[Browserslist]:      https://github.com/ai/browserslist
[Browserslist docs]: https://github.com/ai/browserslist#queries

## Outdated Prefixes

By default, Autoprefixer also removes outdated prefixes.

You can disable this behavior by the `remove: false` option. If you have
no legacy code, this option will make Autoprefixer about 10% faster.

Also, you can set the `add: false` option. Autoprefixer will only clean outdated
prefixes, but not any new prefixes.

Autoprefixer adds new prefixes between any unprefixed properties and already
written prefixes in your CSS. If it will break the expected prefixes order,
you can clean all prefixes from your CSS and then
add the necessary prefixes again:

```js
var cleaner  = postcss([ autoprefixer({ add: false, browsers: [] }) ]);
var prefixer = postcss([ autoprefixer ]);

cleaner.process(css).then(function (cleaned) {
    return prefixer.process(cleaned.css)
}).then(function (result) {
    console.log(result.css);
});
>>>>>>> dev
```

## FAQ

<<<<<<< HEAD
### Does it add polyfills for old browsers?

No. Autoprefixer only adds prefixes, not polyfills. There are two reasons:

1. Prefixes and polyfills are very different and need a different API.
   Two separate libraries would be much better.
2. Most of IE polyfills are very bad for client perfomance. They use slow hacks
   and old IEs is mostly used on old hardware. Most CSS3 features used only
   for styling should be ignored in old IEs as is recommended for
   Graceful Degradation.

### Why don’t gradients work in Firefox?

Check that you use correct [direction syntax]. For example, you should use
`to bottom` instead of `top`:

```css
a {
  background: linear-gradient(to bottom, white, black)
}
```

Unfortunately, unprefixed gradients use a different direction syntax and most
examples you find use an old gradient syntax, so be careful and use always the
latest W3C specs with Autoprefixer.

[direction syntax]: https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient

### Why doesn’t Autoprefixer add prefixes to `border-radius`?

Developers are often surprised by how few prefixes are required today.
If Autoprefixer doesn’t add prefixes to your CSS, check if they’re still
required on [Can I Use](http://caniuse.com/).

If a prefix is required, but Autoprefixer doesn’t add it or adds it
incorrectly, please
[report an issue](https://github.com/ai/autoprefixer/issues/new)
and include your source CSS and expected output.

### Why doesn’t Autoprefixer support `appearance`?

Unlike `transition`, the `appearance` property is not a part of
any specification. So there is no `appearance`, only `-moz-appearance`
and `-webkit-appearance`. Quote from [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/-moz-appearance):

> Do not use this property on Web sites: not only is it non-standard, but its
> behavior changes from one browser to another. Even the keyword `none` does not
> have the same behavior on each form element across different browsers, and
> some do not support it at all.

### Why does Autoprefixer use CoffeeScript?

JavaScript is very popular, but this is the same reason why its syntax does not
evolve. There is an entire Internet with a lot of legacy code which should
be supported by browsers. If developers add an inappropriate feature then
it can’t be removed in then next versions but must be supported for a very
long time. This is very bad for innovation. To create new, we need to experiment
and to choose.

As a result JavaScript doesn’t have even basic syntax features, which are
present in other languages like Ruby or Python. There are no string
interpolation, short lambda syntax, foreach statement for arrays, string and
arrays slicing, etc. This features are really important and they will be in
ECMAScript 6 (first update of JS syntax after 15 years), but this
new specification is still not released and, of course, we must wait until
all browsers support it.

With JavaScript preprocessors like CoffeeScript or TypeScript we can bring
innovation back. We can add a new operator and use it right now, without waiting
for support in all browsers.

Autoprefixer was written in pure JavaScript before. But CoffeeScript made
Autoprefixer code much cleaner and more readable. Often, 2 lines of code
became 1.

Don’t be afraid of CoffeeScript. It is just a new syntax, not another language
(like ClojureScript). You can open [examples on CoffeeScript.org] and start
to code. After a week your eyes will adjust and you will see that CoffeeScript
is cleaner and more readable.

Situation with CoffeeScript and JavaScript is absolutely the same as with
CSS preprocessors and postprocessors. How can we develop a CSS postprocessor
and avoid using a JS preproccesor :).

[examples on CoffeeScript.org]: http://coffeescript.org/

## Usage

### Grunt

You can use the
[grunt-autoprefixer](https://github.com/nDmitry/grunt-autoprefixer)
plugin for Grunt. Install the npm package and add it to Gruntfile:

```js
grunt.loadNpmTasks('grunt-autoprefixer');
```

### Gulp

You can use [gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer)
to use Autoprefixer in your Gulp build configuration.

```js
var prefix = require('gulp-autoprefixer');
gulp.src('./css/*.css')
  .pipe(prefix(["last 1 version", "> 1%", "ie 8", "ie 7"], { cascade: true }))
  .pipe(gulp.dest('./dist/'));
```

### Brunch

You can use the
[autoprefixer-brunch](https://github.com/lydell/autoprefixer-brunch)
plugin for [Brunch](http://brunch.io/).

### Compass

If you use Compass binary to compile your styles, you can easily integrate
Autoprefixer with it. Install `autoprefixer-rails` gem:

```
gem install autoprefixer-rails
```

and add post-compile hook to `config.rb`:

```ruby
require 'autoprefixer-rails'

on_stylesheet_saved do |file|
  css = File.read(file)
  File.open(file, 'w') do |io|
    io << AutoprefixerRails.process(css)
  end
end
```

You can set the browsers option as the second argument in `process` method:

```ruby
io << AutoprefixerRails.process(css, browsers: ["last 1 version", "> 1%"])
```

### Stylus

If you use Stylus CLI, you can add Autoprefixer by
[autoprefixer-stylus](https://github.com/jenius/autoprefixer-stylus) plugin.

Just install npm package and use it in `-u` option:

```
stylus -u autoprefixer-stylus -w file.styl
```

### Ruby on Rails

Add [autoprefixer-rails](https://github.com/ai/autoprefixer-rails) gem
to `Gemfile` and write CSS in a usual way:

```ruby
gem "autoprefixer-rails"
```

### Ruby

You can integrate Autoprefixer into your Sprockets environment
by `autoprefixer-rails` gem:

```ruby
AutoprefixerRails.install(sprockets_env)
```

or process CSS from plain Ruby:

```ruby
prefixed = AutoprefixerRails.process(css)
```

### CodeKit

CodeKit, since the 2.0 version, contains Autoprefixer. In the After Compiling
section, there is a checkbox to enable Autoprefixer.
Read [CodeKit docs](https://incident57.com/codekit/help.html#autoprefixer)
for more inforamtion.

### Prepros

If you want to build your assets with a GUI, try
[Prepros](http://alphapixels.com/prepros/). Just set “Auto Prefix CSS”
[checkbox](https://f.cloud.github.com/assets/3478693/930798/faa29892-0016-11e3-8901-87850de7aed2.jpg)
in right panel.

<img src="http://alphapixels.com/prepros/static/img/prepros.jpg" width="550" height="340" />

### Broccoli

You can use the
[broccoli-autoprefixer](https://github.com/sindresorhus/broccoli-autoprefixer)
plugin for [Broccoli](https://github.com/joliss/broccoli).

### Mincer

To use Autoprefixer in [Mincer](https://github.com/nodeca/mincer),
install `autoprefixer` npm package and enable it:

```js
environment.enable('autoprefixer');
```

### Middleman

Add [middleman-autoprefixer](https://github.com/porada/middleman-autoprefixer)
gem to `Gemfile`:

```ruby
gem "middleman-autoprefixer"
```

and activate the extension in your project’s `config.rb`:

```ruby
activate :autoprefixer
```

### Node.js

Use `autoprefixer` npm package:

```js
var autoprefixer = require('autoprefixer');
var css          = 'a { transition: transform 1s }';
var prefixed     = autoprefixer.process(css).css;
```

### PHP

You can use Autoprefixer in PHP by
[autoprefixer-php](https://github.com/vladkens/autoprefixer-php) library:

```php
$autoprefixer = new Autoprefixer();
$css          = 'a { transition: transform 1s }';
$prefixed     = $autoprefixer->compile($css);
```

### Visual Studio

You can apply the Autoprefixer optimizations to your LESS/Sass stylesheets in
the Visual Studio 2013 by using
the [Web Essentials 2013](http://vswebessentials.com/)
plugin (since the 2.2 version).

To add this functionality in the Visual Studio 2013 you need to do the following
steps:

1. Download and install the [Microsoft Visual Studio 2013 Update 2](http://www.microsoft.com/en-us/download/details.aspx?id=42666)
2. Download and install the [Web Essentials 2013 for Update 2](http://visualstudiogallery.msdn.microsoft.com/56633663-6799-41d7-9df7-0f2a504ca361)
3. Choose a `Tools` → `Options` → `Web Essentials` → `CSS` menu item
4. In the `Enable Autoprefixer` box specify a value equal to `True`
5. Additionally, you can specify the browser conditional expressions
   in the `Targeted browsers` box

<img src="http://i.imgur.com/X9sBBF8.png" width="700" alt="Autoprefixer options in the Web Essentials 2013" />

### .NET

You can use Autoprefixer in .NET by the
[Autoprefixer for .NET](https://github.com/digitalcreations/autoprefixer)
library. Install package via NuGet:

```
PM> Install-Package Autoprefixer
```

### ASP.NET

You can use Autoprefixer in ASP.NET by the official
[BundleTransformer.Autoprefixer](http://www.nuget.org/packages/BundleTransformer.Autoprefixer/)
plugin for [Bundle Transformer](http://bundletransformer.codeplex.com/).

To add this functionality in the ASP.NET web application you need to do the
following steps:

1. Install package via NuGet:

	```
	PM> Install-Package BundleTransformer.Autoprefixer
	```
2. Perform a post-install actions specified in the `readme.txt` file
3. Register a bundles in the `App_Start/BundleConfig.cs` file and configure the
Bundle Transformer (see the [documentation](http://bundletransformer.codeplex.com/documentation))
4. Additionally, you can specify the browser conditional expressions in the 
`Web.config` file (in the Visual Studio supported IntelliSense):

	<img src="http://i.imgur.com/f2iJlBB.png" width="572" alt="BundleTransformer.Autoprefixer options in the Web.config file" />

### JavaScript

You can use Autoprefixer in the browser or as a non-Node.js runtime
with [standalone version](https://raw.github.com/ai/autoprefixer-rails/master/vendor/autoprefixer.js).

### PostCSS

Autoprefixer can be also used as a [PostCSS](https://github.com/ai/postcss)
processor, so you can combine it with other processors and parse CSS only once:

```js
postcss().
    use( autoprefixer(['> 1%', 'opera 12.5']).postcss ).
    use( compressor ).
    process(css);
```

### Sublime Text

You can process your styles directly in Sublime Text with the
[sublime-autoprefixer](https://github.com/sindresorhus/sublime-autoprefixer)
plugin.

### Brackets

Styles can processed automatically in Brackets using the
[brackets-autoprefixer](https://github.com/mikaeljorhult/brackets-autoprefixer)
extension.

### Atom Editor

You can process your styles directly in Atom with the
[atom-autoprefixer](https://github.com/sindresorhus/atom-autoprefixer)
package.

### Others

You can use the `autoprefixer` binary to process CSS files using
any assets manager:

```
sudo npm install --global autoprefixer
autoprefixer *.css
```

See `autoprefixer -h` for help.
=======
#### Does it add polyfills?

No. Autoprefixer only adds prefixes.

Most new CSS features will require client side JavaScript to handle a new
behavior correctly.

Depending on what you consider to be a “polyfill”, you can take a look at some
other tools and libraries. If you are just looking for syntax sugar,
you might take a look at:

- [CSS Grace], a PostCSS plugin that handles some IE hacks (opacity, rgba,
  inline-block, etc) in addition to some non-standard handy shortcuts.
- [cssnext], a tool that allows you to write standard CSS syntax non-implemented
  yet in browsers (custom properties, custom media, color functions, etc).
  It includes autoprefixer and can be used as a PostCSS plugin too.

[CSS Grace]: https://github.com/cssdream/cssgrace
[cssnext]:   https://cssnext.github.io/

#### Why doesn’t Autoprefixer add prefixes to `border-radius`?

Developers are often surprised by how few prefixes are required today.
If Autoprefixer doesn’t add prefixes to your CSS, check if they’re still
required on [Can I Use].

There is a [list with all supported] properties, values, and selectors.

[list with all supported]: https://github.com/postcss/autoprefixer/wiki/support-list
[Can I Use]:               http://caniuse.com/

#### Why Autoprefixer uses unprefixed properties in `@-webkit-keyframes`?

Browser teams can remove some prefixes before others. So we try to use
all combinations of prefixed/unprefixed values.

#### How to work with legacy `-webkit-` only code?

Autoprefixer needs unprefixed property to add prefixes. So if you only
wrote `-webkit-gradient` without W3C’s `gradient`,
Autoprefixer will not add other prefixes.

But [PostCSS] has a plugins to convert CSS to unprefixed state.
Use them before Autoprefixer:

* [postcss-unprefix]
* [postcss-flexboxfixer]
* [postcss-gradientfixer]

[postcss-gradientfixer]: https://github.com/hallvors/postcss-gradientfixer
[postcss-flexboxfixer]:  https://github.com/hallvors/postcss-flexboxfixer
[postcss-unprefix]:      https://github.com/yisibl/postcss-unprefix

#### Does Autoprefixer add `-epub-` prefix?

No, Autoprefixer works only with browsers prefixes from Can I Use.
But you can use [postcss-epub](https://github.com/Rycochet/postcss-epub)
for prefixing ePub3 properties.

## Usage

### Gulp

In Gulp you can use [gulp-postcss] with `autoprefixer` npm package.

```js
gulp.task('autoprefixer', function () {
    var postcss      = require('gulp-postcss');
    var sourcemaps   = require('gulp-sourcemaps');
    var autoprefixer = require('autoprefixer');

    return gulp.src('./src/*.css')
        .pipe(sourcemaps.init())
        .pipe(postcss([ autoprefixer({ browsers: ['last 2 versions'] }) ]))
        .pipe(sourcemaps.write('.'))
        .pipe(gulp.dest('./dest'));
});
```

With `gulp-postcss` you also can combine Autoprefixer
with [other PostCSS plugins].

[other PostCSS plugins]: https://github.com/postcss/postcss#plugins
[gulp-postcss]:          https://github.com/postcss/gulp-postcss

### Webpack

In [webpack] you can use [postcss-loader] with `autoprefixer`
and [other PostCSS plugins].

```js
var autoprefixer = require('autoprefixer');

module.exports = {
    module: {
        loaders: [
            {
                test:   /\.css$/,
                loader: "style-loader!css-loader!postcss-loader"
            }
        ]
    },
    postcss: [ autoprefixer({ browsers: ['last 2 versions'] }) ]
}
```

[other PostCSS plugins]: https://github.com/postcss/postcss#plugins
[postcss-loader]:        https://github.com/postcss/postcss-loader
[webpack]:               http://webpack.github.io/

### Grunt

In Grunt you can use [grunt-postcss] with `autoprefixer` npm package.

```js
module.exports = function(grunt) {
    grunt.loadNpmTasks('grunt-postcss');

    grunt.initConfig({
        postcss: {
            options: {
                map: true,
                processors: [
                    require('autoprefixer')({
                        browsers: ['last 2 versions']
                    })
                ]
            },
            dist: {
                src: 'css/*.css'
            }
        }
    });

    grunt.registerTask('default', ['postcss:dist']);
};
```

With `grunt-postcss` you also can combine Autoprefixer
with [other PostCSS plugins].

[other PostCSS plugins]: https://github.com/postcss/postcss#plugins
[grunt-postcss]:         https://github.com/nDmitry/grunt-postcss

### Other Build Tools:

* **Ruby on Rails**: [autoprefixer-rails]
* **Brunch**: [postcss-brunch]
* **Broccoli**: [broccoli-postcss]
* **Middleman**: [middleman-autoprefixer]
* **Mincer**: add `autoprefixer` npm package and enable it:
  `environment.enable('autoprefixer')`
* **Jekyll**: add `autoprefixer-rails` and `jekyll-assets` to `Gemfile`

[middleman-autoprefixer]: https://github.com/porada/middleman-autoprefixer
[autoprefixer-rails]:     https://github.com/ai/autoprefixer-rails
[broccoli-postcss]:       https://github.com/jeffjewiss/broccoli-postcss
[postcss-brunch]:         https://github.com/iamvdo/postcss-brunch

### Preprocessors

* **Less**: [less-plugin-autoprefix]
* **Stylus**: [autoprefixer-stylus]
* **Compass**: [autoprefixer-rails]

 [less-plugin-autoprefix]: https://github.com/less/less-plugin-autoprefix
 [autoprefixer-stylus]:    https://github.com/jenius/autoprefixer-stylus
 [autoprefixer-rails]:     https://github.com/ai/autoprefixer-rails#compass

### CSS-in-JS

There is [postcss-js] to use Autoprefixer in React Inline Styles, [Free Style],
Radium and other CSS-in-JS solutions.

```js
let prefixer = postcssJs.sync([ autoprefixer ]);
let style = prefixer({
    display: 'flex'
});
```

[postcss-js]: https://github.com/postcss/postcss-js
[Free Style]: https://github.com/blakeembrey/free-style

### GUI Tools

* [CodeKit](https://incident57.com/codekit/help.html#autoprefixer)
* [Prepros](http://alphapixels.com/prepros/)

### CLI

You can use the [postcss-cli] to run Autoprefixer from CLI:

```sh
npm install --global postcss-cli autoprefixer
postcss --use autoprefixer *.css -d build/
```

See `postcss -h` for help.

[postcss-cli]: https://github.com/code42day/postcss-cli

### JavaScript

You can use Autoprefixer with [PostCSS] in your node.js application
or if you want to develop an Autoprefixer plugin for new environment.

```js
var autoprefixer = require('autoprefixer');
var postcss      = require('postcss');

postcss([ autoprefixer ]).process(css).then(function (result) {
    result.warnings().forEach(function (warn) {
        console.warn(warn.toString());
    });
    console.log(result.css);
});
```

There is also [standalone build] for the browser or as a non-Node.js runtime.

You can use [html-autoprefixer] to process HTML with inlined CSS.

[html-autoprefixer]: https://github.com/RebelMail/html-autoprefixer
[standalone build]:  https://raw.github.com/ai/autoprefixer-rails/master/vendor/autoprefixer.js
[PostCSS]:           https://github.com/postcss/postcss

### Text Editors and IDE

Autoprefixer should be used in assets build tools. Text editor plugins are not
a good solution, because prefixes decrease code readability and you will need
to change value in all prefixed properties.

I recommend you to learn how to use build tools like [Gulp].
They work much better and will open you a whole new world of useful plugins
and automatization.

But, if you can’t move to a build tool, you can use text editor plugins:

* [Sublime Text](https://github.com/sindresorhus/sublime-autoprefixer)
* [Brackets](https://github.com/mikaeljorhult/brackets-autoprefixer)
* [Atom Editor](https://github.com/sindresorhus/atom-autoprefixer)
* [Visual Studio](http://vswebessentials.com/)

[Gulp]:  http://gulpjs.com/

## Warnings

Autoprefixer use [PostCSS warning API] to warn about really important problem
in your CSS:

* Old direction syntax in gradients.
* Old unprefixed `display: box` instead of `display: flex`
  by latest specification version.

You can get warnings from `result.warnings()`:

```js
result.warnings().forEach(function (warn) {
    console.warn(warn.toString());
});
```

Every Autoprefixer runner should display this warnings.

[PostCSS warning API]: https://github.com/postcss/postcss/blob/master/docs/api.md#warning-class

## Disabling

Autoprefixer was designed to have no interface – it just works.
If you need some browser specific hack just write a prefixed property
after the unprefixed one.

```css
a {
    transform: scale(0.5);
    -moz-transform: scale(0.6);
}
```

If some prefixes were generated in a wrong way,
please create an issue on GitHub.

But if you do not need Autoprefixer in some part of your CSS,
you can use control comments to disable Autoprefixer.

```css
a {
    transition: 1s; /* it will be prefixed */
}

b {
    /* autoprefixer: off */
    transition: 1s; /* it will not be prefixed */
}
```

Control comments disable Autoprefixer within the whole rule in which
you place it. In the above example, Autoprefixer will be disabled
in the entire `b` rule scope, not only after the comment.

You can also use comments recursively:

```css
/* autoprefixer: off */
@support (transition: all) {
    /* autoprefixer: on */
    a {
        /* autoprefixer: off */
    }
}
```

## Options

Function `autoprefixer(options)` returns new PostCSS plugin.
See [PostCSS API] for plugin usage documentation.

```js
var plugin = autoprefixer({ browsers: ['> 1%', 'IE 7'], cascade: false });
```

There are 4 options:

* `browsers` (array): list of browsers, which are supported in your project.
  You can directly specify browser version (like `IE 7`) or use selections
  (like `last 2 version` or `> 5%`). See [Browserslist docs] for available
  queries and default value.
* `cascade` (boolean): should Autoprefixer uses Visual Cascade,
  if CSS is uncompressed. Default: `true`
* `add` (boolean): should Autoprefixer add prefixes. Default is `true`.
* `remove` (boolean): should Autoprefixer [remove outdated] prefixes.
  Default is `true`.

Plugin object has `info()` method for debug purpose.

You can use PostCSS processor to process several CSS files
to increase perfomance.

[PostCSS API]: https://github.com/postcss/postcss/blob/master/docs/api.md

## Debug

You can check which browsers are selected and which properties will be prefixed:

```js
var info = autoprefixer({ browsers: ['last 1 version'] }).info();
console.log(info);
```
>>>>>>> dev
